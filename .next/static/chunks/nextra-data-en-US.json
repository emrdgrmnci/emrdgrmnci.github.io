{"/":{"title":"Home","data":{"":"","hi-there-#Hi there üëã":"üßëüèº‚Äçüíª I am a software engineer focused on iOS technologies with 5 years of industry experience. I care about details, end-user experience, and solving customer pain points.üë®üèº‚Äçüî¨ I am an active member of a local iOS community here at Izmir called NSIzmir where I share & learn knowledge with & from my fellow iOS developer peers.üì≤ I follow the popular applications about what they are doing.üê£ I have experience with Realm, Core Data, Core Locations,Firebase, Facebook iOS SDK, Restful APIs, SnapKit, Moya, MapKit, MVVM, MVC, TCA, SwiftUI.üå± I‚Äôm currently learning The Composable Architecture, Combine, SwiftUIüí¨ Ask me about iOS Development and Swiftüì´ How to reach me: degirmenci.a.emre@gmail.com"}},"/contact":{"title":"Contact me","data":{"":"Email"}},"/posts":{"title":"Posts","data":{"":"Read my latest blog posts."}},"/posts/Localization":{"title":"Faster localization using POEditor","data":{"":"Localization is a very important step for mobile applications. Because it makes it possible to reach a wide range of customers. üá©üá∞üá≥üá¥üá´üáÆüá∏üá™üáÆüá∏üáµüá±üá±üáªEven almost every people can speak English in Nordic countries, we‚Äôre supporting 7 different Nordic languages in my company.We‚Äôre using POEditor for faster localization processes.https://poeditor.comIn this article, I will explain how to add a language, export, and import localization files in a faster way.First of all, we have a String extension like this:\nextension String {\npublic func localized(_ bundle: Bundle = .locales) -> String {\nNSLocalizedString(self, bundle: bundle, comment: \"\")\n}\n}\n\n//Usage\nclass Foo: UIViewController {\nlet title = \"settings_title\".localized()\n}\nWhen the new strings are added to the code base,\n‚Äúsettings_title‚Äù.localized()\nthen you need to add these new strings to\nAdd the string to the English version of Supporting Files/Localizable.strings i.e.: Project_Directory/Project_Name/Sources/Locales/en.lproj/Localizable.strings\nand send to POEditor (either manually or automatically). Then someone (licensed translator) does the translation in POEditor manually. After that, you should be able to fetch them (either manually or automatically) from POEditor.","how-do-we-extractimport-translations-fromto-poeditor-automatically#How do we extract/import translations from/to POEditor automatically?":"We can either manually send the new strings to poeditor.com using fastlane translations_extract fastlane script or GitLab CI doing it for us automatically. After someone(licensed translator) does the translation in POEditor manually. After all of that has been done we can run the following command fastlane translations_import to fetch the new translations and check them into the codebase.","conclusion#Conclusion":"POEditor is a great localization tool to increase user experience and save time since you will be waiting for translations for the new strings."}},"/posts/Accessibility":{"title":"iOS Accessibility VoiceOver","data":{"":"","what-is-voiceover#What is VoiceOver?":"As you guess disabled people use smartphone apps as well. Designing your apps with accessibility in mind helps everyone use them, including people with vision, or hearing disabilities.\nVoiceOver is a screen reader built into Apple Inc.‚Äôs macOS, iOS, tvOS, watchOS, and iPod operating systems. By using VoiceOver, the user can access their Macintosh or iOS device based on spoken descriptions and, in the case of the Mac, the keyboard.","why-accessibility#Why Accessibility?":"In my current company, we‚Äôre also supporting Accessibilities, especially VoiceOver. In our e-paper applications, we have active 2K blind users.\nYou‚Äôll reach a larger group.\nIt feels good to know you‚Äôre making a noticeable difference in more people‚Äôs life.","how-to-activate-and-use-voiceover#How to Activate and Use VoiceOver?":"You can find detailed information about activation and usage of VoiceOver on iPhone on Apple‚Äôs website:\nhttps://support.apple.com/guide/iphone/iph3e2e415f/ios\nSingle-tap anywhere and VoiceOver will read information from the item‚Äôs accessibility attributes loudly.\nSingle-swipe left or right and VoiceOver will select the next visible accessibility item and read it loudly.\nSingle-swipe down to spell the focused item letter-by-letter.\nDouble-tap to select the specific item.\nThree-finger-swipe left or right to navigate forward or backward in a page view.\n\nFor the complete list of VoiceOver gestures, check out Apple‚Äôs Learn VoiceOver gestures on iPhone. So now you know how VoiceOver works.","accessibility-attributes#Accessibility Attributes":"An accessibility attribute has five properties:First of all, you should define the accessibility element of the UI element.\ntitleLabel.isAccessibilityElement = true\n\naccessibilityLabel: A concise way to identify the control or view.\n\n\ntitleLabel.accessibilityLabel = foo.title\n\naccessibilityTraits: These describe the element‚Äôs state or behavior. A cell trait might be .button, for example.\n\n\ncell.accessibilityTraits = .none\ncell.accessibilityTraits = .button\ncell.accessibilityTraits = .link\ncell.accessibilityTraits = .header\ncell.accessibilityTraits = .adjustable\ncell.accessibilityTraits = .allowsDirectInteraction\ncell.accessibilityTraits = .causesPageTurn\ncell.accessibilityTraits = .image\ncell.accessibilityTraits = .keyboardKey\ncell.accessibilityTraits = .notEnabled\ncell.accessibilityTraits = .playSound\ncell.accessibilityTraits = .searchField\ncell.accessibilityTraits = .startsMediaSession\ncell.accessibilityTraits = .staticText\ncell.accessibilityTraits = .selected\ncell.accessibilityTraits = .summaryElement\ncell.accessibilityTraits = .tabBar\n\naccessibilityHint: Describes the action an element completes. For example:\n\n\nplayButton.accessibilityHint = \"double_tap_to_pause\"\nloginCell.accessibilityHint = \"double_tap_to_log_out\"\n\naccessibilityFrame: The frame of the element within the screen, in the format of a CGRect. VoiceOver speaks the contents of the CGRect.\naccessibilityValue: The value of an element. For example, with a progress bar or a slider, the current value might read: 5 out of 100.","using-the-accessibility-inspector#Using the Accessibility Inspector":"There‚Äôs a tool named Accessibility Inspector, which does the following:\nLets you check the accessibility attributes of UI elements in Inspection Mode.\nProvides live previews of accessibility elements without leaving your app.\nSupports all platforms including macOS, iOS, watchOS, and tvOS.\n\nTo do all of these things, open it in the Xcode menu by navigating to Xcode ‚ñ∏ Open Developer Tool ‚ñ∏ Accessibility Inspector.","conclusion#Conclusion":"You learned about VoiceOver. You used the Accessibility Inspector to perform audits by scrolling through every accessible element. See you üññüèº"}},"/posts/Differences":{"title":"Differences between the work culture/environment of Turkey and Sweden?","data":{"":"Hello there üëãüèª,\nI am a software engineer focused on iOS technologies with 4 years of industry experience. In this time period, I‚Äôve worked in 3 different companies in Turkey as an iOS Developer.Now, I‚Äôve been working at Textalk Media which is a Sweden company works in the Media Technology Industry since 1979 for the past 1 month. This is the very first company that I work abroad for. During this short timeframe, I‚Äôve seen some differences between my past companies and Textalk Media‚Äôs technical scale and products.\nOur Swedish(European) counterparts are deemed happier, healthier, and more productive while working fewer hours, having longer breaks, and more paid vacation.‚Äù https://usalinksystem.com/whats-new/details/6-differences-in-work-culture-between-the-us-and-europe-284\n\nWork culture in Europe and Turkey is like black and white.\nIn Turkey, many employees and some employers (but not so much) are still experimenting to find the perfect work-life balance.","work-hours#Work hours":"In Turkish companies, I was working at least 9 hours per day and 45 hours per week. But, it was not enough for Turkish managers, and they always wait for more hours to work without paying extra money. I was able to endure this bullying for just 3 years ü§Ø. Finally, I burnt out and changed company.In a Swedish company, I am working 8 hours per day and 40 hours per week. And of course, every Friday we have fika time at 15:00 CET and after that, we don‚Äôt work. My company doesn‚Äôt know anything about overtime and always cares about employees‚Äô mental health and decisions.","more-vacation-time#More vacation time":"In Turkish companies, I don‚Äôt remember any time that I used for vacation more than 1 week. On top of it, you have this opportunity if you have been working in that company for at least 1 year.In a Swedish company, I have 25 days of paid vacation (the vacation earning year is April 1 to March 31). I‚Äôm pretty sure no one will disturb me when I will get a vacation ü§†","lunchtime#Lunchtime":"In Turkish companies, this was around a maximum of 30 minutes for me.\n‚ÄúIn Sweden, they have a common practice called fika. Fika at the workplace translates to two 10‚Äì30-minute breaks, one in the morning and another in the afternoon. And they pair Fika with a lunch break that lasts for an hour.‚Äù https://usalinksystem.com/whats-new/details/6-differences-in-work-culture-between-the-us-and-europe-284","technical-perspective#Technical perspective":"In Turkish companies, I have never been in a development environment like every developer checks others' code and comment about it. Opening a Merge Request even üò™ I‚Äôm not saying this for every Turkish company but at least for my former companies environment always was like this. You just write your code and if it is working and solving your current problem you can send this code to production ü•≤ü•≤ü•≤ Also, never been in a Test Driven Development environment.In my current company, the environment is not like my former companies environment, even though we are 2 iOS Engineers. For instance, in my 3rd week, I completed a task without so much testing and created a merge request. As you can guess, like an old habit I completed those tasks don‚Äôt think so much about them, and implemented them in one way. Finally, my colleague didn‚Äôt merge them and said that don‚Äôt think as same as the old developer who wrote this code üòä","tldr#TL;DR":"I tried to compare the work culture between Turkey and Sweden so far, and put some technical perspective. If we do not act hastily and proceed in a more humane way, a higher-quality job will emerge.\nEuropean governments and businesses are looking after their people to boost productivity and improve workers‚Äô work-life balance. https://usalinksystem.com/whats-new/details/6-differences-in-work-culture-between-the-us-and-europe-284\nSee you soon :)"}},"/posts/TCA":{"title":"My journey with The Composable Architecture","data":{"":"In this article, I will give an introduction to The Composable Architecture (TCA) and show my example project.","general-overview#General Overview":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent and understandable way, with composition, testing, and ergonomics in mind, developed by Brandon Williams and Stephen Celis from Point-Free. It can be used in SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","core-tools#Core tools":"State management\n\nHow to manage the state of your application using simple value types, and share state across many screens so that mutations in one screen can be immediately observed in another screen.\nComposition\n\nHow to break down large features into smaller components that can be extracted to their own, isolated modules and be easily glued back together to form the feature.\nSide effects\n\nHow to let certain parts of the application talk to the outside world in the most testable and understandable way possible.\nTesting\n\nHow to not only test a feature built in the architecture, but also write integration tests for features that have been composed of many parts, and write end-to-end tests to understand how side effects influence your application. This allows you to make strong guarantees that your business logic is running in the way you expect.\nErgonomics\n\nHow to accomplish all of the above in a simple API with as few concepts and moving parts as possible.","basic-usage#Basic Usage":"To build a feature using the Composable Architecture you define some types and values that model your domain:\nState: A type that describes the data your feature needs to perform its logic and render its UI.\nAction: A type that represents all of the actions that can happen in your feature, such as user actions, notifications, event sources and more.\nReducer: A function that describes how to evolve the current state of the app to the next state given an action. The reducer is also responsible for returning any effects that should be run, such as API requests, which can be done by returning an Effect value.\nStore: The runtime that actually drives your feature. You send all user actions to the store so that the store can run the reducer and effects, and you can observe state changes in the store so that you can update UI.\n\nThe benefits of doing this are that you will instantly unlock testability of your feature, and you will be able to break large, complex features into smaller domains that can be glued together.","demo-project#Demo Project":"As a basic example, consider a UI that shows a 2-columns grid list along with \"#\" team/player ids, names and, team logos. When the views appear, there is an API request to fetch NBA teams and players and then displays in a 2-columns grid list.üßëüèº‚Äçü¶≥üë®üèº‚Äçü¶≥ To implement this root (grand-parent) feature we create a new type that will house the root domain and behavior of the feature by conforming to Reducer:\nimport ComposableArchitecture\n\nstruct RootFeature: Reducer {}\nIn here we need to define a type for the root feature's state, which consists of a selected tab, as well as parent feature states that are TeamListFeature.State() and PlayerListFeature.State():\nstruct RootFeature: Reducer {\nstruct State: Equatable {\nvar selectedTab = Tab.teams\nvar teamListState = TeamListFeature.State()\nvar playerListState = PlayerListFeature.State()\n}\n}\nWe need to define a type for the feature's tabs. There are the obvious tabbar items, such as teams, favorites and players.\nstruct RootFeature: Reducer {\nstruct State: Equatable {\nvar selectedTab = Tab.teams\nvar teamListState = TeamListFeature.State()\nvar playerListState = PlayerListFeature.State()\n}\nenum Tab {\ncase teams\ncase favorites\ncase players\n}\n}\nWe also need to define a type for the root (grand-parent) feature's actions. There are the obvious actions, such as tabbar item selected, and the actions that are encapsulate all actions from the child domain/feature of the root (grand-parent) domain/feature, providing a comprehensive and cohesive approach.\nstruct RootFeature: Reducer {\nstruct State: Equatable {\nvar selectedTab = Tab.teams\nvar teamListState = TeamListFeature.State()\nvar playerListState = PlayerListFeature.State()\n}\nenum Tab {\ncase teams\ncase favorites\ncase players\n}\nenum Action: Equatable {\ncase tabSelected(Tab)\ncase teamList(TeamListFeature.Action)\ncase playerList(PlayerListFeature.Action)\n}\n}\nAnd then we implement the reduce method which is responsible for handling the actual logic and behavior for the feature. It describes how to change the current state to the next state, and describes what effects need to be executed. Some actions don't need to execute effects, and they can return .none to represent that:\nstruct RootFeature: Reducer {\nstruct State: Equatable {\nvar selectedTab = Tab.teams\nvar teamListState = TeamListFeature.State()\nvar playerListState = PlayerListFeature.State()\n}\n\nenum Tab {\ncase teams\ncase favorites\ncase players\n}\n\nenum Action: Equatable {\ncase tabSelected(Tab)\ncase teamList(TeamListFeature.Action)\ncase playerList(PlayerListFeature.Action)\n}\n\n// Dependencies\nvar fetchTeams: () async throws -> TeamsModel\nvar fetchPlayers:  @Sendable () async throws -> PlayersModel\nvar uuid: @Sendable () -> UUID\n\nstatic let live = Self(\nfetchTeams: MatchScoresClient.liveValue.fetchTeams,\nfetchPlayers: MatchScoresClient.liveValue.fetchPlayers,\nuuid: { UUID() }\n)\n\nvar body: some Reducer<State, Action> {\nReduce { state, action in\nswitch action {\ncase .teamList:\nreturn .none\ncase .playerList:\nreturn .none\ncase .tabSelected(let tab):\nstate.selectedTab = tab\nreturn .none\n}\n}\nScope(state: \\.teamListState, action: /RootFeature.Action.teamList) {\nTeamListFeature(uuid: uuid)\n}\nScope(state:  \\.playerListState, action: /RootFeature.Action.playerList) {\nPlayerListFeature(uuid: uuid)\n}\n}\n}\nAnd then finally we define the view that displays the feature. It holds onto a StoreOf<RootFeature> so that it can observe all changes to the state and re-render, and we can send all user actions to the store so that state changes. WithViewStore is a view helper that transforms a Store into a ViewStore so that its state can be observed by a view builder:\nstruct RootView: View {\nlet store: StoreOf<RootFeature>\n\nvar body: some View {\nWithViewStore(self.store, observe: { $0 }) { viewStore in\nTabView(\nselection: viewStore.binding(\nget: \\.selectedTab,\nsend: RootFeature.Action.tabSelected\n)\n) {\nTeamListView(\nstore: self.store.scope(\nstate: \\.teamListState,\naction: RootFeature.Action\n.teamList\n)\n)\n.tabItem {\nImage(systemName: \"list.bullet\")\nText(\"Teams\")\n}\n.tag(RootFeature.Tab.teams)\n\nPlayerListView(\nstore: self.store.scope(\nstate: \\.playerListState,\naction: RootFeature.Action.playerList\n)\n)\n.tabItem {\nImage(systemName: \"person.fill\")\nText(\"Players\")\n}\n.tag(RootFeature.Tab.players)\n}\n.accentColor(Color(\"launch-screen-background\"))\n}\n}\n}\nOnce we are ready to display these views, for example in the app's entry point, we can construct a store. This can be done by specifying the initial state to start the application in, as well as the reducer that will power the application:\nimport SwiftUI\nimport ComposableArchitecture\n\n@main\nstruct MatchScoresTCAApp: App {\nvar body: some Scene {\nWindowGroup {\nRootView(\nstore: Store(initialState: RootDomain.State()) {\nRootDomain(fetchTeams: { TeamsModel.sample}, fetchPlayers: { PlayersModel.sample }, uuid: { UUID() }\n)\n}\n)\n}\n}\n}\nüë±üèª‚Äç‚ôÇÔ∏èüë±üèºTo implement this parent feature we create a new type that will house the domain and behavior of the feature by conforming to Reducer:\nimport ComposableArchitecture\n\nstruct TeamListFeature: Reducer {\n}\nIn here we need to define a type for the feature's state, which consists of a data loading status, as well as an TeamsModel that is an Identified collection which are designed to solve all of the collection problems by providing data structures for working with collections (teams and meta) of identifiable elements in an ergonomic, performant way:\nstruct TeamListFeature: Reducer {\nstruct State: Equatable {\nvar dataLoadingStatus = DataLoadingStatus.notStarted\nvar resultTeamRequestInFlight: TeamsModel?\nvar teamList: IdentifiedArrayOf<TeamFeature.State> = []\n\nvar shouldShowError: Bool {\ndataLoadingStatus == .error\n}\n\nvar isLoading: Bool {\ndataLoadingStatus == .loading\n}\n}\n}\nWe also need to define a type for the feature's actions. There are the obvious action, such as view on appear and the action that occurs when we receive a response from the team/player API request, and define a team(id: TeamFeature.State.ID, action: TeamFeature.Action) case to handle actions sent to the child domain (TeamFeature: Reducer):\nstruct TeamListFeature: Reducer {\nstruct State: Equatable {\nvar dataLoadingStatus = DataLoadingStatus.notStarted\nvar teamList: IdentifiedArrayOf<TeamFeature.State> = []\nvar shouldShowError: Bool {\ndataLoadingStatus == .error\n}\nvar isLoading: Bool {\ndataLoadingStatus == .loading\n}\n}\nenum Action: Equatable {\ncase fetchTeamResponse(TaskResult<TeamsModel>)\ncase team(id: TeamFeature.State.ID, action: TeamFeature.Action)\ncase onAppear\n}\n}\nAnd then we implement the reduce method which is responsible for handling the actual logic and behavior for the feature. It describes how to change the current state to the next state, and describes what effects need to be executed. Some actions don't need to execute effects, and they can return .none to represent that:\nstruct TeamListFeature: Reducer {\nstruct State: Equatable { /* ... */ }\nenum Action: Equatable { /* ... */ }\n\nfunc reduce(into state: inout State, action: Action) -> Effect<Action> {\nswitch action {\ncase .fetchTeamResponse(.failure(let error)):\nstate.dataLoadingStatus = .error\nprint(error)\nprint(\"Error getting products, try again later.\")\nreturn .none\n\ncase let .fetchTeamResponse(.success(teamData)):\nstate.teamList = IdentifiedArrayOf(\nuniqueElements: teamData.data.map {\nTeamFeature.State(\nid: uuid(),\nteam: $0\n)\n}\n)\nstate.dataLoadingStatus = .loading\nreturn .none\n\ncase .onAppear:\nreturn .run { send in\nawait send (\n.fetchTeamResponse(\nTaskResult { try await MatchScoresClient.liveValue.fetchTeams()\n}\n)\n)\n}\ncase .team:\nreturn .none\n}\n}\n}\nAnd then finally we define the view that displays the feature. It holds onto a StoreOf<TeamListFeature> so that it can observe all changes to the state and re-render, and we can send all user actions to the store so that state changes. ForEachStore loops over a store‚Äôs collection with a store scoped to the domain of each element. This allows us to extract and modularize an element‚Äôs view and avoid concerns around collection index math and parent-child store communication:\nstruct TeamListView: View {\nlet store: StoreOf<TeamListFeature>\n\nprivate let columns = Array(\nrepeating: GridItem( .flexible()),\ncount: 2\n)\n\nvar body: some View {\nWithViewStore(self.store, observe: { $0 }) { viewStore in\nZStack{\nScrollView {\nLazyVGrid(columns: columns,\nspacing: 16) {\nForEachStore(\nself.store.scope(\nstate: \\.teamList,\naction: TeamListFeature.Action.team(id:action:)\n)\n) {\nTeamView(store: $0)\n}\n}\n.padding()\n.accessibilityIdentifier(\"peopleGrid\")\n}\n.refreshable {\nviewStore.send(.onAppear)\n}\n}\n.navigationTitle(\"Teams\")\n.onAppear {\nviewStore.send(.onAppear)\n}\n}\n}\n}\nüë∂üèºüë∂üèº To implement this child (grand-child of RootFeature or child of TeamListFeature) feature we create a new type that will house the domain and behavior of the child feature by conforming to Reducer:\nstruct TeamFeature: Reducer {\nstruct State: Equatable, Identifiable {\nlet id: UUID\nlet team: TeamData\n}\nenum Action: Equatable { }\n\nfunc reduce(into state: inout State, action: Action) -> Effect<Action> { }\n}\nAnd then we define the view that displays the feature. It holds onto a StoreOf<TeamFeature> so that it can observe all changes to the state and re-render, and we can send all user actions to the store so that state changes. WithViewStore is a view helper that transforms a Store into a ViewStore so that its state can be observed by a view builder:\nimport SwiftUI\nimport ComposableArchitecture\n\nstruct TeamView: View {\nlet store: StoreOf<TeamFeature>\n\nvar body: some View {\nWithViewStore(self.store, observe: {$0} ) { viewStore in\nVStack(spacing: .zero) {\n\nbackground\n\nVStack(alignment: .leading) {\nText(viewStore.team.fullName)\n.foregroundColor(Theme.text)\n.font(\n.system(.largeTitle, design: .rounded)\n)\n.background(\nImage(avatars[viewStore.team.id - 1])\n.opacity(0.4)\n.aspectRatio(contentMode: .fill)\n)\n}\n.frame(maxWidth: .infinity, alignment: .leading)\n.frame(height: 150.0)\n.padding(.horizontal, 8)\n.padding(.vertical, 5)\n.background(Theme.detailBackground)\n\nVStack {\nPillView(id: viewStore.team.id)\n.padding(.leading, 10)\n.padding(.top, 10)\n}\n\n}\n.clipShape(\nRoundedRectangle(cornerRadius: 16,\nstyle: .continuous)\n)\n.shadow(color: Theme.text.opacity(0.1),\nradius: 2,\nx: 0,\ny: 1)\n.edgesIgnoringSafeArea([.top, .leading, .trailing])\n}\n}\n}","result#Result":"You can find the all the codes in here"}}}